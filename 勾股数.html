<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //获取输入;
      const n = 30;
      let res = [];
      // c=m^2 + n^2，又m、n都大于0，所以它们一定不超过c的开方
      const len = Math.ceil(Math.sqrt(n));

      for (let i = 1; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
          // m、n不互质，跳过
          // if(isCoprime(i, j) !== 1) continue

          let a = Math.pow(j, 2) - Math.pow(i, 2);
          let b = 2 * i * j;
          let c = Math.pow(j, 2) + Math.pow(i, 2);
          if (c <= n) {
            // 当前勾股数数不超过给定值
            // if ((isCoprime(a, b) === 1) && (isCoprime(a, c) === 1) && (isCoprime(b, c) === 1)) {
            // 勾股数两两互质
            res.push([a, b, c].toString());
            // }
          }
        }
      }

      // 判断两个数是否互质：最大公因数是否为1
      function isCoprime(x, y) {
        // 不必考虑 x、y 的大小 第一次递归之后大的总会在前面
        if (y === 0) {
          return x;
        } else {
          return isCoprime(y, x % y);
        }
      }
      console.log(res, "res");
      // 输出
      let resArr = [];
      for (let i = 3; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          for (let k = j + 1; k < n; k++) {
            if (Math.pow(k, 2) === Math.pow(j, 2) + Math.pow(i, 2)) {
              resArr.push([i, j, k]);
            }
          }
        }
      }
      console.log(resArr, "qqqq");
    </script>
  </body>
</html>
