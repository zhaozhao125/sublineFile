<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      let Person = {
        name: "Tom",
        say(canshu) {
          console.log(arguments, "cansh");
          console.log(`我叫${this.name}`);
        },
      };

      // 先看代码执行效果
      Person1 = {
        name: "Tom1",
      };

      // 我们尝试用原生方法call来实现this指向Person1
      //  Person.say.call(Person1); //我叫Tom1

      Function.prototype.Mycall = function (context) {
        const contextInit = context || window;
        const unique = Symbol();
        contextInit.unique = this;

        const canshu = [...arguments].slice(1);

        contextInit.unique(canshu);
        delete contextInit.unique;
      };
      // Person.say.Mycall(Person1, "a", "b");

      // call的事项原理
      // const fuc = function () {
      //   console.log(this, "thisthis");
      //   console.log("call");
      // };
      // const callObj = {
      //   a: 1,
      // };
      // callObj.fuc = fuc;
      // callObj.fuc();

      Function.prototype.Mybind = function (context) {
        //返回一个绑定this的函数，我们需要在此保存this
        let self = this;
        // 可以支持柯里化传参，保存参数
        let arg = [...arguments].slice(1);
        // 返回一个函数
        return function () {
          //同样因为支持柯里化形式传参我们需要再次获取存储参数
          let newArg = [...arguments];
          // 返回函数绑定this，传入两次保存的参数
          //考虑返回函数有返回值做了return

          return self.apply(context, arg.concat(newArg));
        };
      };

      // // 搞定测试
      let fn = Person.say.Mybind(Person1, "a");
      // fn();
      fn(18);

      // const fucArguments = function () {
      //   console.log(arguments, "arguments");
      // };
      // fucArguments(1, 2, 3, 4);
    </script>
  </body>
</html>
